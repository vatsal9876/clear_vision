# -*- coding: utf-8 -*-
"""utils

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wu-Qq1tNqLCEUUBulf35vXLct5E1dQWm
"""

# utils.py
from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
import torch
import lpips
import numpy as np

# Initialize LPIPS model (AlexNet backbone is common and fast)
lpips_model = lpips.LPIPS(net='alex')

def compute_psnr(original, restored):
    return psnr(original, restored, data_range=255)

def compute_ssim(original, restored):
    return ssim(original, restored, multichannel=True, data_range=255)

def compute_lpips(original, restored):
    """
    original, restored: np.ndarray (H, W, 3), uint8, [0,255]
    Returns: LPIPS score (float)
    """
    # Convert to torch tensor, shape [1,3,H,W], normalized to [-1,1]
    def to_tensor(img):
        img = img.astype(np.float32) / 255.0
        img = torch.from_numpy(img).permute(2,0,1).unsqueeze(0)
        img = img * 2 - 1  # [0,1] -> [-1,1]
        return img

    img0 = to_tensor(original)
    img1 = to_tensor(restored)
    with torch.no_grad():
        lpips_val = lpips_model(img0, img1)
    return float(lpips_val)

from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
import torch
import lpips
import numpy as np

def compute_psnr(original, restored):
    return psnr(original, restored, data_range=255)

def compute_ssim(original, restored):
    return ssim(original, restored, multichannel=True, data_range=255)

# Initialize LPIPS model (AlexNet backbone is common and fast)
lpips_model = lpips.LPIPS(net='alex')

def compute_lpips(original, restored):
    """
    original, restored: np.ndarray (H, W, 3), uint8, [0,255]
    Returns: LPIPS score (float)
    """
    # Convert to torch tensor, shape [1,3,H,W], normalized to [-1,1]
    def to_tensor(img):
        img = img.astype(np.float32) / 255.0
        img = torch.from_numpy(img).permute(2,0,1).unsqueeze(0)
        img = img * 2 - 1  # [0,1] -> [-1,1]
        return img

    img0 = to_tensor(original)
    img1 = to_tensor(restored)
    with torch.no_grad():
        lpips_val = lpips_model(img0, img1)
    return float(lpips_val)
