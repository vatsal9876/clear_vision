# -*- coding: utf-8 -*-
"""utils

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wu-Qq1tNqLCEUUBulf35vXLct5E1dQWm
"""

# utils.py
import numpy as np
import cv2
import random
import tensorflow as tf

def corrupt_image(img):
    img = np.squeeze(img)
    corrupted = img.copy()

    if random.random() < 0.7:
        noise = np.random.normal(0, 0.03, corrupted.shape)
        corrupted += noise
    if random.random() < 0.8:
        corrupted = cv2.GaussianBlur(corrupted, (3, 3), 0)
    if random.random() < 0.5:
        h, w = corrupted.shape[:2]
        top = random.randint(0, h // 2)
        left = random.randint(0, w // 2)
        corrupted[top:top+16, left:left+16] = 0

    return np.clip(corrupted, 0, 1)[np.newaxis, ...]

def compute_psnr(original, restored):
    return tf.image.psnr(original, restored, max_val=1.0).numpy().item()

def compute_ssim(original, restored):
    return tf.image.ssim(original, restored, max_val=1.0).numpy().item()

from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
import torch
import lpips
import numpy as np

# Initialize LPIPS model (AlexNet backbone is common and fast)
lpips_model = lpips.LPIPS(net='alex')

def compute_psnr(original, restored):
    return psnr(original, restored, data_range=255)

def compute_ssim(original, restored):
    return ssim(original, restored, multichannel=True, data_range=255)

def compute_lpips(original, restored):
    """
    original, restored: np.ndarray (H, W, 3), uint8, [0,255]
    Returns: LPIPS score (float)
    """
    # Convert to torch tensor, shape [1,3,H,W], normalized to [-1,1]
    def to_tensor(img):
        img = img.astype(np.float32) / 255.0
        img = torch.from_numpy(img).permute(2,0,1).unsqueeze(0)
        img = img * 2 - 1  # [0,1] -> [-1,1]
        return img

    img0 = to_tensor(original)
    img1 = to_tensor(restored)
    with torch.no_grad():
        lpips_val = lpips_model(img0, img1)
    return float(lpips_val)

from skimage.metrics import peak_signal_noise_ratio as psnr
from skimage.metrics import structural_similarity as ssim
import torch
import lpips
import numpy as np

def compute_psnr(original, restored):
    return psnr(original, restored, data_range=255)

def compute_ssim(original, restored):
    return ssim(original, restored, multichannel=True, data_range=255)

# Initialize LPIPS model (AlexNet backbone is common and fast)
lpips_model = lpips.LPIPS(net='alex')

def compute_lpips(original, restored):
    """
    original, restored: np.ndarray (H, W, 3), uint8, [0,255]
    Returns: LPIPS score (float)
    """
    # Convert to torch tensor, shape [1,3,H,W], normalized to [-1,1]
    def to_tensor(img):
        img = img.astype(np.float32) / 255.0
        img = torch.from_numpy(img).permute(2,0,1).unsqueeze(0)
        img = img * 2 - 1  # [0,1] -> [-1,1]
        return img

    img0 = to_tensor(original)
    img1 = to_tensor(restored)
    with torch.no_grad():
        lpips_val = lpips_model(img0, img1)
    return float(lpips_val)